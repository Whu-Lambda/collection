è¦ç‚¹ï¼š

- æšä¸¾ä½“çš„æ¦‚å¿µ
- æ¨¡å¼åŒ¹é…
- æšä¸¾ä½“ `Option`
- æšä¸¾ä½“`Result`

# æšä¸¾ä½“çš„æ¦‚å¿µ

åœ¨å¼€å§‹å­¦ä¹  Rust è¯­è¨€æšä¸¾ä½“æ¦‚å¿µä¹‹å‰ï¼Œå…ˆå›é¡¾ C è¯­è¨€æšä¸¾ä½“ä¸è”åˆä½“çš„ç”¨æ³•ï¼š

C è¯­è¨€æšä¸¾ä½“ï¼š

```c
#include<stdio.h>
enum week{Mon=10, Tue, Wed, Thur, Fri=10, Sat=16, Sun};
enum day{Mond, Tues, Wedn, Thurs, Frid=18, Satu=11, Sund};
int main() {
   printf("The value of enum week: %d\t%d\t%d\t%d\t%d\t%d\t%d\n\n",Mon , Tue, Wed, Thur, Fri, Sat, Sun);
   printf("The default value of enum day: %d\t%d\t%d\t%d\t%d\t%d\t%d",Mond , Tues, Wedn, Thurs, Frid, Satu, Sund);
   return 0;
}
```

è¿è¡Œç»“æœï¼š

```shell
The value of enum week: 10	11	12	13	10	16	17

The default value of enum day: 0	1	2	3	18	11	12
```

æ³¨ï¼šä»¥ä¸Šä¾‹å­å‚è€ƒï¼šhttps://www.tutorialspoint.com/enum-in-c

C è¯­è¨€è”åˆä½“ï¼š

```c
#include <stdio.h>
#include <string.h>
 
union Data {
   int i;
   float f;
   char str[20];
};
 
int main( ) {

   union Data data;
   int i;
   float f;
   char str[20];

   printf( "int: %d, float: %d, char[20]: %d, total : %d\n",sizeof(i), sizeof(f), sizeof(str), sizeof(data));

   return 0;
}
```

è¿è¡Œç»“æœï¼š

```shell
int: 4, float: 4, char[20]: 20, total : 20
```

ä»ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹å‡º C è¯­è¨€çš„æšä¸¾ä½“å…¶å®å®šä¹‰äº†ä¸€ç»„æ•´æ•°å€¼ã€‚

Rust è¯­è¨€çš„æšä¸¾ä½“åƒ C è¯­è¨€æšä¸¾ä½“å’Œè”åˆä½“çš„ç»¼åˆä½“ï¼Œå®ƒæºè‡ªäºå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€å¦‚ Haskell çš„ [sum type](https://www.quora.com/What-is-a-sum-type)ã€‚Rust è¯­è¨€æšä¸¾ä½“ä¸ä»…å¯ä»¥åŒ…å«æšä¸¾é¡¹ï¼Œæ¯ä¸ªæšä¸¾é¡¹è¿˜å¯ä»¥åŒ…å«å€¼ã€‚

ğŸ’¡ sum type å°±æ˜¯ä¸€ä¸ªç±»å‹å¯èƒ½ç”±æŸäº›å­ç±»å‹ç»„æˆï¼Œå®ƒçš„å€¼æ˜¯å±äºå­ç±»å‹ä¸­çš„æŸä¸€ä¸ªã€‚

ä¸‹é¢æ¥çœ‹ä¸€ä¸ª Rust è¯­è¨€æšä¸¾ä½“ç¤ºä¾‹ï¼š

```rust
enum WebEvent {
    PageLoad,
    PageUnload,
    KeyPress(char),
    Paste(String),
    Click { x: i64, y: i64 },
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad => println!("page loaded"),
        WebEvent::PageUnload => println!("page unloaded"),
        WebEvent::KeyPress(c) => println!("pressed '{}'.", c),
        WebEvent::Paste(s) => println!("pasted \"{}\".", s),
        WebEvent::Click { x, y } => {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    let pasted  = WebEvent::Paste(String::from("my text"));
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
```

ğŸ“è¦ç‚¹æ€»ç»“ï¼š

- ä»ä»¥ä¸Šä¾‹å­å¯ä»¥çœ‹å‡º Rust è¯­è¨€çš„æšä¸¾ä½“å°±åƒç»“æ„ä½“ç»„åˆå™¨ï¼Œå¯ä»¥æ˜¯ä¸‰ç§ç»“æ„ä½“çš„ä»»ä½•ä¸€ç§ã€‚
- Rust è¯­è¨€ä½¿ç”¨æšä¸¾é€‰é¡¹é¡»ä½¿ç”¨åŸŸè¿ç®—ç¬¦`::`ã€‚



Rust ä¹Ÿå¯ä»¥è½»æ¾æ„é€ ç±» C çš„æšä¸¾ä½“ï¼š

```rust
#[derive(Debug)]
enum HttpStatus {
    OK = 200,
    NotModified = 304,
    NotFound = 404,
}

fn main() {
    println!("{:?}, {:?}", HttpStatus::OK, HttpStatus::NotFound);
    assert_eq!(HttpStatus::NotModified as i32, 304);
}
```



ç”¨ Rust æšä¸¾ä½“å¯ä»¥ç›´è§‚è¡¨è¾¾æ•°æ®çš„å±‚æ¬¡ç»“æ„ï¼š

```rust
use std::collections::HashMap;
enum Json {
    Null,
    Boolean(bool),
    Number(f64),
    String(String),
    Array(Vec<Json>),
    Object(Box<HashMap<String, Json>>),
}
```

ğŸ’¡ `Box<HashMap<String, Json>>` å¯èƒ½ä¸å¥½ç†è§£ï¼Œå®ƒå…¶å®æ˜¯ä¸€ä¸ªæŒ‡å‘ `HashMap<String, Json>` çš„å †æŒ‡é’ˆï¼Œå¯ä»¥ç®€å•çš„æŠŠ `Box<HashMap<String, Json>>` ç†è§£ä¸ºä¸€ä¸ª  `HashMap` å¯¹è±¡ã€‚ 



# æ¨¡å¼åŒ¹é…

æ¨¡å¼åŒ¹é…ä¸ Rust æšä¸¾ä½“æ˜¯å¤©é€ åœ°è®¾çš„ä¸€å¯¹ï¼Œä¸¤è€…é…åˆä½¿ç”¨æ‰èƒ½å‘æŒ¥æœ€å¤§æ•ˆç›Šã€‚

| æ¨¡å¼ç±»å‹   | ç¤ºä¾‹                                    | è§£é‡Š                                        |
| ---------- | --------------------------------------- | ------------------------------------------- |
| å­—é¢å€¼     | `100, "name"`                           | åŒ¹é…ç¡®åˆ‡çš„å€¼                                |
| èŒƒå›´       | `0..=100`                               | åŒ¹é…åŒºé—´`[0,100]` çš„æ•´æ•°ï¼Œå­—æ¯ä¹Ÿå¯ä»¥        |
| å¿½ç•¥ç¬¦     | `_`                                     | åŒ¹é…ä»»æ„å€¼å¹¶å¿½ç•¥è¯¥å€¼                        |
| å˜é‡       | `name, mut count`                       | åŒ¹é…ä»»æ„å€¼å¹¶æŠŠå€¼è½¬ç§»æˆ–å¤åˆ¶åˆ°è¯¥å˜é‡          |
| `ref` å˜é‡ | `ref field, ref mut field`              | ä¸è½¬ç§»æˆ–å¤åˆ¶åŒ¹é…çš„å€¼ï¼ŒäºŒæ˜¯å€Ÿç”¨åŒ¹é…å€¼çš„å¼•ç”¨  |
| å­æ¨¡å¼ç»‘å®š | `val @ 0..=100, ref circle @ Circle`    | åŒ¹é… `@` å³ä¾§çš„æ¨¡å¼ï¼Œå¹¶æŠŠå€¼ç»‘å®šåˆ°å·¦ä¾§çš„å˜é‡ |
| ç»“æ„ä½“æ¨¡å¼ | `Color(r,g,b)ï¼ŒPoint{x, y:0}ï¼ŒUser{..}` | åŒ¹é…ç›¸åº”çš„ç»“æ„ä½“æ¨¡å¼ï¼Œæœ‰ç‚¹åƒç»“æ„ä½“è§£æ„      |
| å…ƒç»„æ¨¡å¼   | `(r,g,b), (key,value)`                  | åŒ¹é…æŸä¸ªå…ƒç»„æ¨¡å¼                            |
| æšä¸¾æ¨¡å¼   | `None, Some(value), HttpStatus::Ok`     | æŸä¸ªæšä¸¾é¡¹                                  |
| å¼•ç”¨       | `&value`                                | åŒ¹é…å¼•ç”¨                                    |
| å¤šä¸ªæ¨¡å¼   | `'a'|'b'|'c'`                           | åªè¦ä¸€ä¸ªæ¨¡å¼åŒ¹é…æ•´ä¸ªå°±åŒ¹é…ï¼Œç›¸å½“äºæˆ–        |
| é™„åŠ æ¡ä»¶   | `x if x*x < 10`                         | åŒ¹é…æ»¡è¶³æ¡ä»¶çš„å˜é‡                          |

å¤‡æ³¨ï¼š

- èŒƒå›´ `0..=100` çš„è¯­æ³•è€ç‰ˆæœ¬å†™ä½œ `0...100`ï¼›
- é™„åŠ æ¡ä»¶æœ‰ä¸ªä¸“é—¨çš„åå­—ï¼šmatch guardã€‚

è¿™é‡Œæˆ‘ä»¬å°±ä¸æ”¾ä¾‹å­äº†ï¼Œç›¸å…³èµ„æ–™ï¼š

- å®˜æ–¹æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/book/ch18-03-pattern-syntax.html



# æšä¸¾ä½“ `Option`

Rust å†…ç½®äº†è®¸å¤šæœ‰ç”¨çš„æšä¸¾ä½“ï¼Œå…¶ä¸­æœ€å¸¸ç”¨çš„æ˜¯ `Option`ï¼Œå®ƒå¸¸ç”¨æ¥åŒ…è£¹æŸäº›æ“ä½œçš„ç»“æœã€‚å…ˆçœ‹å®ƒçš„å®šä¹‰ï¼š

```rust
pub enum Option<T> {
    None,
    Some(T),
}
```

ğŸ“è¦ç‚¹è§£è¯»ï¼š

- ä½ å¯èƒ½çº ç»“`<T>`ï¼Œå®ƒè¡¨ç¤ºæ³›å‹å‚æ•°ï¼Œç”¨äºæŒ‡å®š `Some(T)` å€¼çš„ç±»å‹ã€‚
- ä»å®ƒçš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œè¿™ä¸ªæšä¸¾ä½“è¦ä¹ˆè¡¨ç¤ºæ²¡æœ‰å€¼ï¼š`None`ï¼Œè¦ä¹ˆæ˜¯æœ‰å€¼ï¼š`Some(T)`

å…ˆçœ‹ä¸€ä¸ªç¤ºä¾‹ï¼š

```rust
fn division(dividend: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None
    } else {
        Some(dividend / divisor)
    }
}

fn display_division(dividend: i32, divisor: i32) {
    match division(dividend, divisor) {
        None => println!("Oops, divisor == 0"),
        Some(quotient) => {
            println!("{} / {} = {}", dividend, divisor, quotient)
        },
    }
}

fn main() {
    display_division(4, 2); // 4 / 2 = 2
    display_division(1, 0); // Oops, divisor == 0
}
```

ä¸Šè¿°ä»£ç å±•ç¤ºäº†å¦‚ä½•ä¼˜é›…çš„å¤„ç†é™¤æ³•ã€‚æ¥ä¸‹æ¥è¦ä»‹ç» `enum Option` å‡ ä¸ªå¸¸ç”¨çš„æ–¹æ³•ï¼š

ï¼ˆ1ï¼‰`unwrape()`

```rust
fn main() {
    let x = Some(3);
    let y = Some(4);
    println!("{:?}", x + y);
}
```

è¿è¡Œç»“æœï¼š

```shell
error[E0369]: cannot add `Option<{integer}>` to `Option<{integer}>`
  --> src\main.rs:21:24
   |
21 |     println!("{:?}", x + y);
   |                      - ^ - Option<{integer}>
   |                      |
   |                      Option<{integer}>

error: aborting due to previous error
```

ä¿®æ”¹ä»£ç ï¼š

```rust
fn main() {
    let x = Some(3).unwrap();
    let y = Some(4).unwrap();
    println!("{:?}", x + y); // 7
}
```

å¯è§`unwrape()` å°±æ˜¯æŠŠ `Some` é‡Œçš„å€¼å–å‡ºæ¥ã€‚

ï¼ˆ2ï¼‰`unwrape_or()`

å…ˆçœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
fn main() {
    let x = Some(3).unwrap();
    let y: Option<i32> = None;
    println!("{:?}", x + y.unwrap());
}
```

è¿è¡Œç»“æœï¼š

```shell
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\main.rs:21:28
```

å¯¹ `None` å–å€¼ä¼šæŠ¥é”™ï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š

```rust
fn main() {
    let x = Some(3).unwrap();
    let y: Option<i32> = None;
    println!("{:?}", x + y.unwrap_or(4)); // 7
}
```

æ›´å¤šç”¨æ³•è§å®˜æ–¹æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/std/option/enum.Option.html

# æšä¸¾ä½“ `Result`

Rust è¯­è¨€æ²¡æœ‰`try catch exception` ä¹‹ç±»çš„å¼‚å¸¸å¤„ç†æ¨¡å—ï¼ŒRust è¯­è¨€çš„å¼‚å¸¸å¤„ç†ä¾èµ– `enum Result`ï¼Œè¯·çœ‹å®šä¹‰ï¼š

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¦‚æœæˆåŠŸï¼Œå°±æŠŠç›¸åº”çš„ç»“æœæ”¾åœ¨ `Ok` é€‰é¡¹é‡Œï¼Œå¦‚æœå‡ºé”™ï¼Œå°±æŠŠé”™è¯¯ä¿¡æ¯æ”¾åœ¨ `Err` é€‰é¡¹é‡Œã€‚æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("tests/hello.txt");

    match f {
        Ok(file) => {
            // handle file
            println!("{:?}", file);
        }
        Err(error) => {
            // handle error
            println!("{:?}", error);
        }
    };
}
```

ğŸ“è¦ç‚¹è§£è¯»ï¼š

- ä¸Šè¿°ç¨‹åºçš„ç»“æ„éå¸¸æ¸…æ™°ï¼Œ`File::open()` è¿”å›ä¸€ä¸ª `Result` æšä¸¾ä½“ï¼Œç„¶åæˆ‘ä»¬å¯¹ç»“æœè¿›è¡Œæ¨¡å¼åŒ¹é…ï¼Œå¦‚æœæ˜¯`Ok`ï¼Œå°±æ‰§è¡Œæ–‡ä»¶å¤„ç†ç›¸å…³æ“ä½œï¼›å¦‚æœæ˜¯ `Err` å°±å¤„ç†é”™è¯¯ã€‚
- Rust æ‰“å¼€æ–‡ä»¶æ“ä½œä¸çš„å·¥ä½œè·¯å¾„ä¸è¿è¡Œ `cargo run` çš„ç›¸åŒï¼Œæ³¨æ„è¿™ä¸ªç»†èŠ‚ï¼Œè°ƒè¯•çš„æ—¶å€™å¯èƒ½å¸®åˆ°ä½ ã€‚
- ä½ å¯ä»¥æ‰“å¼€ä¸€ä¸ªä¸å­˜åœ¨çš„æ–‡ä»¶å’Œå­˜åœ¨çš„è·¯å¾„å¯¹æ¯”ç»“æœã€‚

æ¥ä¸‹æ¥ä»‹ç»å‡ ä¸ª`Result`å¸¸ç”¨çš„æ–¹æ³•ã€‚

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("tests/hello.txt").unwrap();

    let f2 = File::open("tests/hello.txt").expect("Faild to open file");

    let f3 = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```

ğŸ“è¦ç‚¹è§£è¯»ï¼š

- `unwrape()`ï¼šå¦‚æœè¿”å›`Ok`ï¼Œå°±è¿”å› `Ok` é‡Œçš„å†…å®¹ï¼Œå¦åˆ™ç»ˆæ­¢çº¿ç¨‹å¹¶æŠ¥é”™ã€‚
- `expect()`ï¼šä¸`unwrape()` ç±»ä¼¼ï¼Œåªæ˜¯å¯ä»¥è‡ªå®šä¹‰æŠ¥é”™ä¿¡æ¯ã€‚
- `unwrape_or_else()`ï¼šæ¥æ”¶ä¸€ä¸ªé”™è¯¯å¤„ç†å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œä¸Šè¿°ä¾‹å­é‡‡ç”¨çš„åŒ¿åå‡½æ•° `|error| {...}` ï¼Œå¦‚æœæˆåŠŸå°±è¿”å› `Ok` é‡Œçš„å†…å®¹ï¼Œå¦åˆ™ä»¥é”™è¯¯ä¿¡æ¯ `error` ä½œä¸ºå‚æ•°è°ƒç”¨é”™è¯¯å¤„ç†å‡½æ•°ã€‚

å†çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
use std::error::Error;
use std::fs::File;
use std::io;
use std::io::Read;

fn read_config_from_file() -> Result<String, io::Error> {
    let mut f = File::open("config.toml")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

fn main() -> Result<(), Box<dyn Error>> {
    let config = read_config_from_file()?;
    println!("{:?}", config);
    Ok(())
}
```

ğŸ“è¦ç‚¹è§£è¯»ï¼š

- è¿™æ®µä»£ç çš„éœ€æ±‚æ˜¯è¯»å–é…ç½®æ–‡ä»¶çš„å†…å®¹ï¼Œä»”ç»†è§‚å¯Ÿä½ ä¼šå‘ç° `read_config_from_file()`  å’Œ  `main()`  éƒ½è¿”å›ä¸€ä¸ª `Result`ï¼Œè€Œä¸”å¯èƒ½å‡ºé”™çš„å‡½æ•°è°ƒç”¨åé¢è·Ÿäº†ä¸€ä¸ª `?`ã€‚
- `?` æ“ä½œç¬¦æ˜¯é‡ç‚¹ï¼Œå®ƒè¡¨ç¤ºé”™è¯¯å†’æ³¡ï¼ˆ[Propagating Errors](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors)ï¼‰ï¼Œå³å¦‚æœå‡½æ•°è¿”å›é”™è¯¯çš„ç»“æœå°±ç«‹å³ç»ˆæ­¢ï¼Œå¹¶æŠŠé”™è¯¯ä¿¡æ¯ä¼ é€’ç»™å¤–å±‚è°ƒç”¨ç›´åˆ°é”™è¯¯è¢«æˆªè·å¤„ç†ã€‚å®ƒçš„ç­‰ä»·ç‰ˆæœ¬å¦‚ä¸‹ï¼š

```rust
fn read_config_from_file() -> Result<String, io::Error> {
    let f = File::open("config.toml");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

æ›´å¤šèµ„æ–™

- æ¥å£æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/beta/core/result/enum.Result.html
- å®˜æ–¹æ•™ç¨‹ï¼šhttps://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html

